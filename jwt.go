// Copyright 2020 Raomx. All rights reserved.
// Use of this source code is governed by MIT
// license that can be found in the LICENSE file.

// Package jwt is a easy and minimal implementation of JWT, and just implements HMAC SHA-256.
// It just has two APIs, Parse() and GetToken().
//
// How to get a jwt token:
// claims = Claims {
//     "name": raomx,
//    "age":   38,
// }
// token := claims.GetToken()
//
//
// How to get Claims from token:
// token := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NzkxOTc0OTUsImlhdCI6MTU3OTE5MDI5NSwiaXNzIjoiYXV0aC5leGFtcGxlLmNvbSIsImp0aSI6IjAxZTZjNTczLTQ4YzQtNDYyMi04M2U3LThiNjRhZDNkZjg0NyIsIm5iZiI6MTU3OTE5MDI5NSwibmFtZSI6InJhb214IiwiYWdlIjozOH0.3jGXEPaXLuUsH8R-m-BDQght3-IhoUHDO7kK5gR0CsA"
// claims, err :=  Parse(token)
// if err := nil {
//     return fmt.Errorf("Parse %s err: %w", token, err)
// }
// name := claims["name"]
package jwt

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
	"time"
)

// The Secret of HMAC SHA-256, generated by a func RandByte(), and length between 25-32.
var secret []byte

// Type of Claims
type Claims map[string]interface{}

// The registered claims of the JWT.
const (
	tokenID = "jti"

	issuer = "iss"

	issuedAt = "iat"

	expiresAt = "exp"

	notBeforeAt = "nbf"
)

// issuer and expires can be changed.
var (

	iss = "jwt.example.com"

	tokenDur = 2 * time.Hour
)

// Set secret
func init()  {
	secret = RandByte()
}

// Get Token from Claims.
func (cusClaims Claims)GetToken() string {
	headerEnc, _ := json.Marshal(map[string]interface{}{"alg": "HS256","typ": "JWT"})
	cusClaims.setRegClaims()
	claimsEnc, _ := json.Marshal(cusClaims)

	jwtStr := fmt.Sprintf(
		"%s.%s",
		base64.RawURLEncoding.EncodeToString(headerEnc),
		base64.RawURLEncoding.EncodeToString(claimsEnc),
	)

	// Sign with sha 256
	mac := hmac.New(sha256.New, secret)
	mac.Write([]byte(jwtStr))

	return fmt.Sprintf("%s.%s", jwtStr, base64.RawURLEncoding.EncodeToString(mac.Sum(nil)))
}

// Get Claims from a token, if secret , or header, or registered claims is not right,
// the error is not nil.
func Parse(tokenStr string) (Claims, error) {

	if ! verifyToken(tokenStr) {
		return nil, errTokenInvalid
	}

	tokenArray := strings.Split(tokenStr, ".")

	// Make sure token contains 3 parts
	if len(tokenArray) != 3 {
		return nil, errTokenInvalid
	}

	if err := verifyHeader(tokenArray[0]); err != nil {
		return nil, err
	}

	claimsByte, err := base64.RawURLEncoding.DecodeString(tokenArray[1])
	if err != nil {
		return nil, err
	}

	var claims = Claims{}
	if err := json.Unmarshal(claimsByte, &claims); err != nil {
		return nil, err
	}

	if err := claims.validate(); err != nil {
		return nil, err
	}

	return claims, nil
}

// Set issuer.
func SetIss(issuer string)  {
	iss = issuer
}

// Set expires.
func SettokenDur(dur time.Duration)  {
	tokenDur = dur
}

// Has Method of Claims.
func (claims Claims) Has(name string) bool {
	_, ok := claims[name]
	return ok
}
